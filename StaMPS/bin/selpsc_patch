#!/usr/bin/env python3
"""
selpsc_patch: Calculate dispersion of a stack of SLCs and generate PS candidates
based on the dispersion threshold.
"""

import numpy as np
import warnings
import argparse

from pathlib import Path
from contextlib import ExitStack

np.set_printoptions(precision=4, suppress=True)
warnings.filterwarnings("ignore")

def log(msg):
    """Log a message."""
    print(msg)

def filedim(fn):
    size = fn.stat().st_size
    nlines = size // (width * np.dtype(ts).itemsize)
    return (nlines, width)

parser = argparse.ArgumentParser()
parser.add_argument("parmfile")
parser.add_argument("patch_in")
parser.add_argument("pscands_ij", default="pscands.1.ij", nargs="?")
parser.add_argument("pscands_da", default="pscands.1.da", nargs="?")
parser.add_argument("mean_amp", default="mean_amp.flt", nargs="?")
parser.add_argument("precision", choices=["s", "f"], default="f", nargs="?")
parser.add_argument("byteswap", choices=[0, 1], default=0, type=int, nargs="?")
parser.add_argument("Dsq", default="Dsq.flt", nargs="?")
parser.add_argument("pos", default="pos.bin", nargs="?")
args = parser.parse_args()

if args.precision == "s":
    raise NotImplementedError
else:
    ts = ">c8"

log(f"dtype: {ts} ({np.dtype(ts).kind} {np.dtype(ts).itemsize * 8}-bit)")

calib_factor = []
D_thresh = 0.0
width = 0
fns = []

with open(args.parmfile) as fd:
    D_thresh = float(fd.readline())
    width = int(fd.readline())
    for line in fd:
        c1, c2 = line.split()
        fns.append(Path(c1))
        calib_factor.append(float(c2))

with open(args.patch_in) as fd:
    rg_start = int(fd.readline())
    rg_end = int(fd.readline())
    az_start = int(fd.readline())
    az_end = int(fd.readline())

for fn, c in zip(fns, calib_factor):
    azs, rgs = filedim(fn)
    print(f"{fn} mean_amp:{c:6.4f} azs:{azs} rgs:{rgs}")

calib = np.array(calib_factor)
nlines, width = filedim(fns[0])
nfiles = len(fns)
D_sq_thresh = D_thresh**2
rg_start = max(0, rg_start - 1)
rg_end = min(width, rg_end - 1)
az_start = max(0, az_start - 1)
az_end = min(nlines, az_end - 1)
pscid = 0

log(f"nfiles = {nfiles}")
log(f"dispersion threshold = {D_thresh:.4f}")
log(f"dispersion-squared threshold = {D_sq_thresh:.4f}")
log(f"width = {width}")
log(f"nlines = {nlines}")
log(f"rg_start = {rg_start}")
log(f"rg_end = {rg_end}")
log(f"az_start = {az_start}")
log(f"az_end = {az_end}")

nskip = 0

inazrg = {}
inazrgfn = Path(args.parmfile).resolve().parent / "input_azrg"
if inazrgfn.exists():
    print(f"Found {inazrgfn}. Also adding points from that file.")
    with open(inazrgfn) as fd:
        for line in fd.readlines():
            az, rg = [int(x)-1 for x in line.strip().split()]
            inazrg.setdefault(az, []).append(rg)

with ExitStack() as stack:
    pfd = stack.enter_context(open(args.pos, "w"))
    mfd = stack.enter_context(open(args.mean_amp, "w"))
    Dsqfd = stack.enter_context(open(args.Dsq, "w"))
    ijfd = stack.enter_context(open(args.pscands_ij, "w"))
    dafd = stack.enter_context(open(args.pscands_da, "w"))
    slcfds = [stack.enter_context(open(f)) for f in fns]

    for az in range(nlines):
        arr = np.array(
            [np.fromfile(fd, dtype=ts, count=width) for fd in slcfds], dtype=ts
        )

        if not (az_start <= az <= az_end):
            nskip += 1
            continue

        # arr = arr[:, rg_start:rg_end]

        amp = np.absolute(arr)

        for i in range(len(calib)):
            amp[i, :] /= calib[i]

        mask = amp < 0.00005
        amp[mask] = np.nan
        mask = np.count_nonzero(mask, axis=0) > 1

        sumamp = np.nansum(amp, axis=0)
        sumampsq = np.nansum(amp**2, axis=0)
        D_sq = nfiles * sumampsq / (sumamp * sumamp) - 1  # var / mean^2

        D_sq[mask] = np.nan

        rgloc = list(np.argwhere(D_sq < D_sq_thresh).flat)

        if az in inazrg:
            frgs = inazrg[az]
            print(f"at azimuth: {az}, adding fixed ranges: {frgs}")
            rgloc.extend(frgs)

        pos = np.zeros_like(D_sq, dtype=np.ubyte)
        pos[rgloc] = 1

        if az % 100 == 0:
            print(f"line {az} / {nlines}  {np.nanmedian(D_sq):.4f} {len(rgloc)}")

        for rg in rgloc:
            if rg_start <= rg <= rg_end:
                ijfd.write(f"{pscid} {az + 1} {rg + 1}\n")
                dafd.write(f"{np.sqrt(D_sq[rg]):.4f}\n")
                pscid += 1

        sumamp[mask] = 0
        D_sq[mask] = 0

        meanamp = sumamp / nfiles

        meanamp.astype(">f4").tofile(mfd)  # 32-bit float big-endian
        D_sq.astype(">f4").tofile(Dsqfd)
        pos.astype(">B").tofile(pfd)

print(f"{nskip} lines skipped")
print(
    f"{pscid} PS candidates generated ({pscid / ((az_end - az_start)*(rg_end-rg_start)) * 100:.2f}% of patch pixels)"
)
print(f"PS candidates stored in {args.pscands_ij}")
